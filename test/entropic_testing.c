/**
 * Test for camera_reader and downsampling integration
 */
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

#include "../include/camera_reader.h"
#include "../include/downsampler.h"
#include "../include/entropic_enc.h"
#include "../include/globals.h"
#include "../include/quantizer.h"
#include "../player/entropic_decoder.h"
#include "../player/quantizer_decoder.h"

int ratio_height_YUV;
int ratio_width_YUV;
int pppyUV;
int pppxUV;

int main(int argc, char* argv[])
{
    //test_fijo();
    //exit(0);
    CAMERA_OPTIONS options;
    MMAL_COMPONENT_T *camera;
    int status;
    pthread_t camera_down_thread;
    pthread_t down_quantizer_thread;
    pthread_t entropic_streamer_thread;

    options.width = 640;
    options.height = 480;
    options.framerate = 10;
    options.cameraNum = 0;
    options.sensor_mode = 6;

    DEBUG = false;
    yuv_model = 2; // 4:2:0
    pppx = 2;
    pppy = 2;
    uint8_t * hops_obtained, *component_obtained;
    hops_obtained = calloc(1000,sizeof(uint8_t));
    component_obtained = calloc(1000,sizeof(uint8_t));
    int tam_bits_Y;
    int tam_bits_U;
    int tam_bits_V;


    camera = init_camera(&options);
    ratio_height_YUV=height_orig_Y/height_orig_UV;
    ratio_width_YUV=width_orig_Y/width_orig_UV;
    pppyUV=2*pppy/ratio_height_YUV;
    pppxUV=2*pppx/ratio_width_YUV;

    init_downsampler();
    init_quantizer();
    init_entropic_enc();

    for(int j =0; j<100; j++)
    {
        pthread_mutex_lock (&cam_down_mutex);
        pthread_cond_wait (&cam_down_cv,&cam_down_mutex);
        for(int line =0 ; line< height_down_Y; line++) {
            //Coding
            down_avg_horiz(orig_Y,width_orig_Y,orig_down_Y,line,pppx,pppy);
            quantize_scanline( orig_down_Y,  line, width_down_Y, hops_Y,result_Y);
            tam_bits_Y =entropic_enc(hops_Y, bits_Y, line, width_down_Y);
            int tam_bytes = tam_bits_Y%8 ? (tam_bits_Y/8)+1: tam_bits_Y/8;
            //Decoding
            int readed_bytes;
            int readed_symbols;

            readed_symbols = decode_symbols_entropic(bits_Y[line], hops_obtained, tam_bytes+20, width_down_Y, &readed_bytes);

            //Check
            if(readed_bytes != tam_bytes){
                printf("Error readed_bytes=%d is not equal to the tam_bytes=%d generated\n", readed_bytes, tam_bytes);
                break;
            }

            if(readed_symbols != width_down_Y){
                printf("Error readed_symbols=%d is not equal to the widtd=%d\n",readed_symbols, width_down_Y);
                break;
            }
            for (int i =0; i< width_down_Y; i++){
                if(hops_obtained[i] != hops_Y[line][i]){
                    printf("Error in the symbol=%d line=%d\n", i, line);
                    break;
                }
            }

            decode_line_quantizer(hops_obtained, component_obtained, readed_symbols);
            for (int i =0; i< width_down_Y; i++){
                if(component_obtained[i] != result_Y[line][i]){
                    printf("Error in the x=%d line=%d component_obtained=%d result_Y=%d hop=%d\n", i, line,component_obtained[i],result_Y[line][i], hops_obtained[i]);
                    break;
                }
            }


        }
        pthread_mutex_unlock (&cam_down_mutex);
        printf("%d frame right \n", j);
    }
    return 0;
}

void test_fijo(){
// Obtained from the encoding and decoding in linux which works fine.

/* Original Hops

0x71db0: 07 05 04 04 04 04 04 04|03 04 05 04 03 04 05 04    ................
0x71dc0: 03 04 05 04 03 04 05 04|03 04 05 04 03 04 05 04    ................
0x71dd0: 03 04 05 04 03 04 05 04|03 04 05 04 03 04 05 02    ................
0x71de0: 04 03 03 04 04 05 06 04|02 03 04 04 04 04 04 05    ................
0x71df0: 04 07 05 04 04 04 04 03|01 07 04 02 02 03 04 03    ................
0x71e00: 04 04 03 04 03 06 05 03|04 04 04 04 02 03 04 04    ................
0x71e10: 04 04 03 04 04 04 05 05|04 02 04 03 04 04 04 04    ................
0x71e20: 05 03 04 04 05 03 04 04|04 04 04 05 04 04 03 04    ................
0x71e30: 05 04 04 03 04 03 05 05|04 03 05 04 04 03 04 04    ................
0x71e40: 04 05 04 04 04 03 04 05|04 03 04 04 05 03 05 03    ................
0x71e50: 05 03 04 05 04 04 03 04|04 05 02 04 04 04 04 04    ................
0x71e60: 04 04 04 04 04 04 03 04|05 04 03 04 04 04 04 05    ................
0x71e70: 03 05 03 05 04 04 03 04|04 05 04 04 05 04 04 04    ................
0x71e80: 04 04 04 03 04 05 04 04|03 04 04 05 03 05 04 03    ................
0x71e90: 04 05 04 03 05 03 05 04|03 04 05 04 03 04 05 04    ................
0x71ea0: 03 04 05 03 05 04 04 03|04 05 04 03 04 05 04 03    ................
0x71eb0: 04 05 04 03 04 05 03 04|05 04 04 03 04 05 04 04    ................
0x71ec0: 03 04 04 05 04 04 04 03|04 05 03 04 05 04 04 03    ................
0x71ed0: 04 04 04 05 04 03 05 04|03 04 05 04 04 04 03 04    ................
0x71ee0: 04 04 04 05 04 04 03 04|05 04 04 04 03 04 05 04    ................
 total:320;
*/
uint8_t original_hops[320] = {
0x07, 0x05, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x03, 0x04, 0x05, 0x04, 0x03, 0x04, 0x05, 0x04,
0x03, 0x04, 0x05, 0x04, 0x03, 0x04, 0x05, 0x04, 0x03, 0x04, 0x05, 0x04, 0x03, 0x04, 0x05, 0x04,
0x03, 0x04, 0x05, 0x04, 0x03, 0x04, 0x05, 0x04, 0x03, 0x04, 0x05, 0x04, 0x03, 0x04, 0x05, 0x02,
0x04, 0x03, 0x03, 0x04, 0x04, 0x05, 0x06, 0x04, 0x02, 0x03, 0x04, 0x04, 0x04, 0x04, 0x04, 0x05,
0x04, 0x07, 0x05, 0x04, 0x04, 0x04, 0x04, 0x03, 0x01, 0x07, 0x04, 0x02, 0x02, 0x03, 0x04, 0x03,
0x04, 0x04, 0x03, 0x04, 0x03, 0x06, 0x05, 0x03, 0x04, 0x04, 0x04, 0x04, 0x02, 0x03, 0x04, 0x04,
0x04, 0x04, 0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x04, 0x02, 0x04, 0x03, 0x04, 0x04, 0x04, 0x04,
0x05, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x04, 0x04, 0x04, 0x05, 0x04, 0x04, 0x03, 0x04,
0x05, 0x04, 0x04, 0x03, 0x04, 0x03, 0x05, 0x05, 0x04, 0x03, 0x05, 0x04, 0x04, 0x03, 0x04, 0x04,
0x04, 0x05, 0x04, 0x04, 0x04, 0x03, 0x04, 0x05, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x05, 0x03,
0x05, 0x03, 0x04, 0x05, 0x04, 0x04, 0x03, 0x04, 0x04, 0x05, 0x02, 0x04, 0x04, 0x04, 0x04, 0x04,
0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x03, 0x04, 0x05, 0x04, 0x03, 0x04, 0x04, 0x04, 0x04, 0x05,
0x03, 0x05, 0x03, 0x05, 0x04, 0x04, 0x03, 0x04, 0x04, 0x05, 0x04, 0x04, 0x05, 0x04, 0x04, 0x04,
0x04, 0x04, 0x04, 0x03, 0x04, 0x05, 0x04, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x05, 0x04, 0x03,
0x04, 0x05, 0x04, 0x03, 0x05, 0x03, 0x05, 0x04, 0x03, 0x04, 0x05, 0x04, 0x03, 0x04, 0x05, 0x04,
0x03, 0x04, 0x05, 0x03, 0x05, 0x04, 0x04, 0x03, 0x04, 0x05, 0x04, 0x03, 0x04, 0x05, 0x04, 0x03,
0x04, 0x05, 0x04, 0x03, 0x04, 0x05, 0x03, 0x04, 0x05, 0x04, 0x04, 0x03, 0x04, 0x05, 0x04, 0x04,
0x03, 0x04, 0x04, 0x05, 0x04, 0x04, 0x04, 0x03, 0x04, 0x05, 0x03, 0x04, 0x05, 0x04, 0x04, 0x03,
0x04, 0x04, 0x04, 0x05, 0x04, 0x03, 0x05, 0x04, 0x03, 0x04, 0x05, 0x04, 0x04, 0x04, 0x03, 0x04,
0x04, 0x04, 0x04, 0x05, 0x04, 0x04, 0x03, 0x04, 0x05, 0x04, 0x04, 0x04, 0x03, 0x04, 0x05, 0x04};


/* Obtained hops from entropic
         07 05 04 04 04 04 04 04|03 04 05 04 03 04 05 04    ................
0x4d410: 03 04 05 04 03 04 05 04|03 04 05 04 03 04 05 04    ................
0x4d420: 03 04 05 04 03 04 05 04|03 04 05 04 03 04 05 02    ................
0x4d430: 04 03 03 04 04 05 06 04|02 03 04 04 04 04 04 05    ................
0x4d440: 04 07 05 04 04 04 04 03|01 07 04 02 02 03 04 03    ................
0x4d450: 04 04 03 04 03 06 05 03|04 04 04 04 02 03 04 04    ................
0x4d460: 04 04 03 04 04 04 05 05|04 02 04 03 04 04 04 04    ................
0x4d470: 05 03 04 04 05 03 04 04|04 04 04 05 04 04 03 04    ................
0x4d480: 05 04 04 03 04 03 05 05|04 03 05 04 04 03 04 04    ................
0x4d490: 04 05 04 04 04 03 04 05|04 03 04 04 05 03 05 03    ................
0x4d4a0: 05 03 04 05 04 04 03 04|04 05 02 04 04 04 04 04    ................
0x4d4b0: 04 04 04 04 04 04 03 04|05 04 03 04 04 04 04 05    ................
0x4d4c0: 03 05 03 05 04 04 03 04|04 05 04 04 05 04 04 04    ................
0x4d4d0: 04 04 04 03 04 05 04 04|03 04 04 05 03 05 04 03    ................
0x4d4e0: 04 05 04 03 05 03 05 04|03 04 05 04 03 04 05 04    ................
0x4d4f0: 03 04 05 03 05 04 04 03|04 05 04 03 04 05 04 03    ................
0x4d500: 04 05 04 03 04 05 03 04|05 04 04 03 04 05 04 04    ................
0x4d510: 03 04 04 05 04 04 04 03|04 05 03 04 05 04 04 03    ................
0x4d520: 04 04 04 05 04 03 05 04|03 04 05 04 04 04 03 04    ................
0x4d530: 04 04 04 05 04 04 03 04|05 04 04 04 03 04 05 04

total 320
*/

uint8_t recovered_hops[320] = {
0x07, 0x05, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x03, 0x04, 0x05, 0x04, 0x03, 0x04, 0x05, 0x04,
0x03, 0x04, 0x05, 0x04, 0x03, 0x04, 0x05, 0x04, 0x03, 0x04, 0x05, 0x04, 0x03, 0x04, 0x05, 0x04,
0x03, 0x04, 0x05, 0x04, 0x03, 0x04, 0x05, 0x04, 0x03, 0x04, 0x05, 0x04, 0x03, 0x04, 0x05, 0x02,
0x04, 0x03, 0x03, 0x04, 0x04, 0x05, 0x06, 0x04, 0x02, 0x03, 0x04, 0x04, 0x04, 0x04, 0x04, 0x05,
0x04, 0x07, 0x05, 0x04, 0x04, 0x04, 0x04, 0x03, 0x01, 0x07, 0x04, 0x02, 0x02, 0x03, 0x04, 0x03,
0x04, 0x04, 0x03, 0x04, 0x03, 0x06, 0x05, 0x03, 0x04, 0x04, 0x04, 0x04, 0x02, 0x03, 0x04, 0x04,
0x04, 0x04, 0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x04, 0x02, 0x04, 0x03, 0x04, 0x04, 0x04, 0x04,
0x05, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x04, 0x04, 0x04, 0x05, 0x04, 0x04, 0x03, 0x04,
0x05, 0x04, 0x04, 0x03, 0x04, 0x03, 0x05, 0x05, 0x04, 0x03, 0x05, 0x04, 0x04, 0x03, 0x04, 0x04,
0x04, 0x05, 0x04, 0x04, 0x04, 0x03, 0x04, 0x05, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x05, 0x03,
0x05, 0x03, 0x04, 0x05, 0x04, 0x04, 0x03, 0x04, 0x04, 0x05, 0x02, 0x04, 0x04, 0x04, 0x04, 0x04,
0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x03, 0x04, 0x05, 0x04, 0x03, 0x04, 0x04, 0x04, 0x04, 0x05,
0x03, 0x05, 0x03, 0x05, 0x04, 0x04, 0x03, 0x04, 0x04, 0x05, 0x04, 0x04, 0x05, 0x04, 0x04, 0x04,
0x04, 0x04, 0x04, 0x03, 0x04, 0x05, 0x04, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x05, 0x04, 0x03,
0x04, 0x05, 0x04, 0x03, 0x05, 0x03, 0x05, 0x04, 0x03, 0x04, 0x05, 0x04, 0x03, 0x04, 0x05, 0x04,
0x03, 0x04, 0x05, 0x03, 0x05, 0x04, 0x04, 0x03, 0x04, 0x05, 0x04, 0x03, 0x04, 0x05, 0x04, 0x03,
0x04, 0x05, 0x04, 0x03, 0x04, 0x05, 0x03, 0x04, 0x05, 0x04, 0x04, 0x03, 0x04, 0x05, 0x04, 0x04,
0x03, 0x04, 0x04, 0x05, 0x04, 0x04, 0x04, 0x03, 0x04, 0x05, 0x03, 0x04, 0x05, 0x04, 0x04, 0x03,
0x04, 0x04, 0x04, 0x05, 0x04, 0x03, 0x05, 0x04, 0x03, 0x04, 0x05, 0x04, 0x04, 0x04, 0x03, 0x04,
0x04, 0x04, 0x04, 0x05, 0x04, 0x04, 0x03, 0x04, 0x05, 0x04, 0x04, 0x04, 0x03, 0x04, 0x05, 0x04};

/*bits obtained
0xc9768: 05 fc d9 b3 66 cd 9b 36|6c d9 a1 93 a3 09 fb 05    .üÙ³fÍ6lÙ¡£.û.
0xc9778: f2 04 18 42 67 32 29 f0|9f 3d 61 9f 4e 9f b9 b9    ò..Bg2)ð=aN¹¹
0xc9788: 95 97 3d e6 ce 94 a6 e7|43 fc 8d 9f 4a 5c ee fe    =æÎ¦çCüJ\îþ
0xc9798: 6e 74 b3 65 2c d9 b3 4b|9b 36 6c d3 73 73 bc d3    nt³e,Ù³K6lÓss¼Ó
0xc97a8: 73 d9 66 f3 ee 6f 36 00|00 00 00 00 00 00 00 00    sÙfóîo6.........

ttoal 71

*/
uint8_t bits_obtained[71] = {
0x05, 0xfc, 0xd9, 0xb3, 0x66, 0xcd, 0x9b, 0x36, 0x6c, 0xd9, 0xa1, 0x93, 0xa3, 0x09, 0xfb, 0x05,
0xf2, 0x04, 0x18, 0x42, 0x67, 0x32, 0x29, 0xf0, 0x9f, 0x3d, 0x61, 0x9f, 0x4e, 0x9f, 0xb9, 0xb9,
0x95, 0x97, 0x3d, 0xe6, 0xce, 0x94, 0xa6, 0xe7, 0x43, 0xfc, 0x8d, 0x9f, 0x4a, 0x5c, 0xee, 0xfe,
0x6e, 0x74, 0xb3, 0x65, 0x2c, 0xd9, 0xb3, 0x4b, 0x9b, 0x36, 0x6c, 0xd3, 0x73, 0x73, 0xbc, 0xd3,
0x73, 0xd9, 0x66, 0xf3, 0xee, 0x6f, 0x36};

    int readed_bytes;
    int readed_symbols;
    uint8_t actual_recovered_hops[320];

    readed_symbols = decode_symbols_entropic(bits_obtained, actual_recovered_hops, 71+20, 320, &readed_bytes);

    if(readed_bytes != 71){
            printf("Error readed_bytes=%d is not equal to 71\n", readed_bytes);
    }

    if(readed_symbols != 320){
        printf("Error readed_symbols=%d is not equal to the widtd=%d\n",readed_symbols, width_down_Y);
    }
    for (int i =0; i< 320; i++){
        if(recovered_hops[i] != actual_recovered_hops[i]){
            printf("Error in the symbol=%d", i);
        }
    }
    printf("finish\n");
    return;
}
